#ifndef IMODULEMANAGER_H
#define IMODULEMANAGER_H

#include <QObject>
#include <memory>
#include <functional>
#include <QLibrary>
#include "iembeddedlanguagemanager.h"
#include "EmbeddedDefinitions.h"
#include "engine_global.h"

namespace BrowserAutomationStudioFramework
{
    class FunctionRunData;

    class ENGINESHARED_EXPORT IModuleManager : public QObject
    {
        Q_OBJECT
    public:
        typedef char* (*ResizeFunction)(int,void*);
        typedef void* (*ModuleOnStartFunction)();
        typedef void (*ModuleOnEndFunction)(void*);
        typedef void (*ModuleOnIddleFunction)(void*);
        typedef void (*ModuleWorkFunction)(char *InputJson, ResizeFunction AllocateSpace, void *AllocateData, void* DllData, void* ThreadData, unsigned int ThreadId, bool *NeedToStop, bool *WasError);

        struct ModuleFunctionClass
        {
            QString Alias;
            bool IsAsync;
            bool IsWaitInfinite;
            ModuleWorkFunction WorkFunction;
        };
        using ModuleFunction = std::shared_ptr<ModuleFunctionClass>;

        struct ModuleDllClass
        {
            QString Name;
            QString FileName;
            QLibrary *Library = 0;
            ModuleOnStartFunction StartDllFunction;
            ModuleOnEndFunction EndDllFunction;
            ModuleOnStartFunction StartThreadFunction;
            ModuleOnEndFunction EndThreadFunction;
            ModuleOnIddleFunction IddleThreadFunction;
            QList<ModuleFunction> FunctionList;
            ~ModuleDllClass()
            {
                if(Library)
                {
                    Library->unload();
                    delete Library;
                }
                StartDllFunction = 0;
                EndDllFunction = 0;
                StartThreadFunction = 0;
                EndThreadFunction = 0;
                IddleThreadFunction = 0;
            }
        };
        using ModuleDll = std::shared_ptr<ModuleDllClass>;


        struct ModuleInfoClass
        {
            QString Name;
            QString Description;
            QString DeveloperName;
            QString DeveloperEmail;
            QString DeveloperSite;
            QString IconPath;
            QList<QString> EngineCode;
            QList<QString> BrowserCode;
            QList<ModuleDll> Dlls;
            int ApiVersion;
            int MajorVersion;
            int MinorVersion;
            bool IsEnabled;
            QString Folder;
            QList<EmbeddedLanguage> EmbeddedLanguages;
            QList<EmbeddedModule> EmbeddedModules;
            QList<EmbeddedCodeItem> EmbeddedCodeItems;
        };

        using ModuleInfo = std::shared_ptr<ModuleInfoClass>;


        struct ModulePreserveClass
        {
            QString Name;
            QString Folder;
            QByteArray Data;
            bool IsUnconditionallyIncluded = false;
            bool IsAutogenerated = false;
        };

        using ModulePreserve = std::shared_ptr<ModulePreserveClass>;



        explicit IModuleManager(QObject *parent = 0);
        virtual void TransferModulesFromOldVersion() = 0;

        virtual QList<EmbeddedLanguage> GetAllEmbeddedLanguages() = 0;
        virtual QList<EmbeddedModule> GetAllEmbeddedModules() = 0;
        virtual QList<EmbeddedCodeItem> GetAllEmbeddedCodeItems() = 0;

        virtual QList<EmbeddedLanguage> GetAllEmbeddedLanguages(QStringList& ActiveModules) = 0;
        virtual QList<EmbeddedModule> GetAllEmbeddedModules(QStringList& ActiveModules) = 0;
        virtual QList<EmbeddedCodeItem> GetAllEmbeddedCodeItems(QStringList& ActiveModules) = 0;


        virtual QList<ModuleInfo> GetModuleInfo(bool InitializeLibraries) = 0;
        virtual bool IsModuleEnabled(const QString& ModuleName) = 0;
        virtual void SetModuleEnabled(const QString& ModuleName, bool IsEnabled) = 0;
        virtual int GetModuleSystemVersion() = 0;
        virtual QList<QString> GetModuleEngineCode(const QStringList& Exclude) = 0;
        virtual void CacheBrowserCode() = 0;
        virtual void StartAllDlls() = 0;
        virtual void StopAllDlls() = 0;
        virtual void StartThread(unsigned int ThreadId) = 0;
        virtual void StopThread(unsigned int ThreadId) = 0;
        virtual bool GetIsRunning() = 0;
        virtual FunctionRunData * PrepareExecuteFunction(const QString& DllName, const QString& FunctionName, const QString& InputParam, unsigned int ThreadId) = 0;

        virtual QList<ModulePreserve> GetAllModules() = 0;
        virtual QList<ModulePreserve> GetModulesUsedInProject(const QString& Project, bool IncludeStandartModulesWithEmbeddedLanguages = false) = 0;
        virtual QStringList GetStandartModulesNotUsedInProject(const QString& Project) = 0;
        virtual bool PackModules(QList<ModulePreserve>& Modules) = 0;
        virtual void UnpackModules(QList<ModulePreserve>& Modules) = 0;
        virtual void ClearPreserveCache() = 0;

    signals:

    public slots:

    };

    char* ResizeFunctionImpl(int size,void *AllocateData);

    class FunctionRunData : public QObject
    {
        Q_OBJECT
        public:
            explicit FunctionRunData(QObject *parent = 0);

            IModuleManager::ModuleWorkFunction FunctionPointer;
            QString DllName;
            QString FunctionName;
            std::vector<char> InputJson;
            std::vector<char>  OutputJson;
            void* DllData;
            void* ThreadData;
            unsigned int ThreadId;
            bool IsError;
            std::string ErrorString;
            bool IsAync;
            bool WaitInfinite;
            bool NeedToStop;
            bool ExecuteError;
        signals:
            void ReadyResult();
            void Finished();
        public slots:
            void Execute();
            void Stop();
    };
}

#endif // IMODULEMANAGER_H

