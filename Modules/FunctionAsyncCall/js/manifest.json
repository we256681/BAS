{
	
	"name": "FunctionAsyncCall",
	"info": {"en": "This module allows to start function execution in separate thread, wait for results or stop it if necessary.", "ru": "Этот модуль позволяет начать выполнение функции в отдельном потоке, дождаться результатов или остановить его при необходимости."},
	"icon": "async.png",
	"description": "Call function asynchronously",
	"description_small": {"en": "Call function asynchronously", "ru": "Асинхронный вызов функции"},
	"major_version": 1,
	"minor_version": 0,
	"developer_name": "bablosoft", 
	"developer_email": "mail.to.twaego@gmail.com", 
	"developer_site": "https://bablosoft.com",
	"api_version": 1,
	"actions":
	[
		{
			"name": "asyncfunction_call",
			"description": {"en": "Call function asynchronously","ru": "Вызов функции асинхронно"},
			"template": "{{FunctionName}}",
			"is_element": false,
			"interface": "asyncfunction_call_interface.js",
			"select": "asyncfunction_call_select.js",
			"code": [{"file":"asyncfunction_call_code.js", "name": "asyncfunction_call_code"}],
			"suggestion":{"en": "create new thread, start thread, multithreading","ru": "создать новый поток, запустить поток, многопоточность, многопоток"}

		},
		{
			"name": "asyncfunction_wait",
			"description": {"en": "Wait for async function completion","ru": "Ждать завершение асинхронной функции"},
			"template": "{{ThreadId}}",
			"is_element": false,
			"interface": "asyncfunction_wait_interface.js",
			"select": "asyncfunction_wait_select.js",
			"code": [{"file":"asyncfunction_wait_code.js", "name": "asyncfunction_wait_code"}]
		},
		{
			"name": "asyncfunction_result",
			"description": {"en": "Get async function result","ru": "Получить результат асинхронной функции"},
			"template": "{{ThreadId}} -> {{Result}}",
			"is_element": false,
			"interface": "asyncfunction_result_interface.js",
			"select": "asyncfunction_result_select.js",
			"code": [{"file":"asyncfunction_result_code.js", "name": "asyncfunction_result_code"}]
		},
		{
			"name": "asyncfunction_stop",
			"description": {"en": "Stop async function","ru": "Прервать асинхронную функцию"},
			"template": "{{ThreadId}}",
			"is_element": false,
			"interface": "asyncfunction_stop_interface.js",
			"select": "asyncfunction_stop_select.js",
			"code": [{"file":"asyncfunction_stop_code.js", "name": "asyncfunction_stop_code"}]
		}
	],
	"localize": 
	{
		"Result thread id": {"ru": "Результат. ID потока"},
		"Instead of function result, this variable contains identifier, which can be used to obtain function result when function will finish. It also allows communicating with function, with help of it you can: obtain function result, wait for function completion or stop function.": {"ru": "Вместо результата функции эта переменная содержит идентификатор, который можно использовать для получения результата функции после ее завершения. Он также позволяет взаимодействовать с функцией, с помощью него вы можете: получить результат функции, дождаться завершения функции или остановить функцию."},
		"Desired thread id": {"ru": "Желаемый ID потока"},
		"Start in a new thread": {"ru": "Запуск в новом потоке"},
		"Identifier for thread, where function will start. By default function will be started in new thread, but you can change that behavior by modifying this value.": {"ru": "ID потока, в котором будет запускаться функция. По умолчанию функция будет запущена в новом потоке, но вы можете изменить это поведение, задав данное значение."},
		"Start task in a new thread. New thread id will be returned in 'Result thread id' parameter.": {"ru": "Запустить функцию в новом потоке. ID созданного потока будет возвращен в параметре 'Результат. ID потока'."},
		"Start task in old thread. THREAD_ID variable must be obtained as a result of previously called 'Call function asynchronously' action. Previous action call must set 'Close thread after function finish' parameter to false, otherwise thread will be stopped.": {"ru": "Запустить функцию в созданном ранее потоке. Переменная THREAD_ID должна быть получена в результате ранее вызванного действия 'Вызов функции асинхронно'. Предыдущий вызов действия должен установить для параметра 'Остановить поток после завершения функции' значение false, иначе поток будет остановлен преждевременно."},
		"Close thread after function finish": {"ru": "Остановить поток после завершения функции"},
		"Close thread after function will finish": {"ru": "Остановить поток после завершения функции"},
		"Don't close thread<br/>Next function can be called in this thread": {"ru": "Не останавливать поток<br/>Следующая функция может запущена в этом потоке"},
		"If thread must be stopped after this function will finish execution. Default value is true, which helps to prevent hanging threads. Set it to false only if you want to use this thread later.": {"ru": "Должен ли поток быть остановлен после того, как эта функция завершит выполнение. Значение по умолчанию - true, оно помогает избежать утечки потоков. Если вы хотите использовать этот поток позже, установите значение false."},
		"Don't close thread. Next function can be called in this thread. Use 'Desired thread id' to start new function in same thread.": {"ru": "Не останавливать поток. Следующая функция может быть вызвана в этом потоке. Используйте параметр 'Желаемый ID потока', чтобы указать поток для запуска."},
		"Maximum async tasks executed simultaneously": {"ru": "Максимальное количество асинхронных функций, выполняемых одновременно"},
		"Maximum simultaneously running threads with async functions per application. If function will be started beyond the limit, it will be postponed and will be started immediately after some other async function will finish and the limit will not be exceeded. This is very powerful setting, it allows you to start as many threads as you want and let BAS balance thread number.": {"ru": "Максимум одновременно работающих потоков с асинхронными функциями. Лимит устанавливается для всего приложения целиком. Если функция будет запущена свыше этого предела, она будет отложена до того момента, когда завершится какая-то другая функция и число потоков упадет ниже предела. Это очень мощная настройка, она позволяет запускать неограниченное число потоков, при этом BAS будет балансировать нагрузку самостоятельно."},
		"Limit the number of threads to 30. Default.": {"ru": "Ограничить количество потоков до 30. Значение по умолчанию."},
		"Execute async functions sequentially.": {"ru": "Выполнять асинхронные функции последовательно."},
		"Limit the number of threads to 100.": {"ru": "Ограничить количество потоков до 100."},
		"List where thread id will be added": {"ru": "Список, куда будет добавлен ID потока"},
		"List, where thread id will be added. This variable has a list type and can be processed with \"List\" module. It accumulates all started threads so, you can perform bulk actions on it, for example, stop them immediately all together. If variable doesn't exist, it will be created.": {"ru": "Список, куда будет добавлен ID потока. Эта переменная имеет тип список и может обрабатываться модулем \"Список\". Он накапливает все запущенные потоки, поэтому вы можете выполнять с помощью него действия сразу над несколькими потоками, например, немедленно останавливать их. Если переменная не существует, она будет создана."},
		"Execute function asynchronously without waiting for its completion.": {"ru": "Выполнить функцию асинхронно не дожидаясь её завершения."},
		"Function must be defined beforehand. BAS allows define functions through \"Function Manager\"": {"ru": "Функция должна быть определена заранее. BAS позволяет определять функции используя \"Менеджер функций\""},
		"Functions are containers, which holds action list. It helps to group several actions which does same task. For example, there can be function which logins to account, function that checks account balance, etc. It makes your code clear and well organized.": {"ru": "Функции - это контейнеры, в которых содержится список действий. Они помогают группировать несколько действий, которые выполняют одну и ту же задачу. Например, может быть функция, которая логинится на сайте, функция, которая проверяет баланс и т. д. Это делает ваш код понятным и хорошо организованным."},
		"Another advantage is that one function may be executed as many times as you want from any place in the script. This helps to avoid code duplication. If you want to update function, you need to do that only once, not in every place where it used.": {"ru": "Другим преимуществом является то, что одна функция может выполняться столько раз, сколько вы хотите и из любого места. Это помогает избежать повторения кода. Если вы хотите изменить функцию, вам нужно сделать это только один раз, а не в любом месте, где она используется."},
		"This action will start a new thread and execute function in it with specified parameters.": {"ru": "Это действие запустит новый поток и выполнит в нем функцию с указанными параметрами."},
		"It is important to understand that because of function will be started in a new thread, all local variables won't be available inside function. Function will use completely different browser. It means that, for example, authorization on sites performed in thread that called function won't be available inside function.": {"ru": "Важно понимать, что из-за того, что функция будет запущена в новом потоке, все локальные переменные не будут доступны внутри нее. Функция будет использовать совершенно другой браузер. Это означает, что, например, авторизация на сайте, выполненная в потоке, который вызвал функцию, не будет доступна внутри функции."},
		"Sharing data. You can pass data to function by setting input parameters, results from function may be obtained by using \"Get async function result\" action. Results are available only after function finished working.": {"ru": "Обмен данными. Вы можете передать данные в функцию, установив входные параметры, результаты из нее можно получить с помощью действия \"Получить результат асинхронной функции\". Результаты доступны только после завершения работы функции."},
		"Execution of this action will finish immediately upon invocation even if function execution itself takes significant time.": {"ru": "Выполнение этого действия завершится сразу после его вызова, даже если само выполнение функции занимает значительное время."},
		"You can wait for one or several asynchronous functions to finish by using \"Wait for async function completion\" action.": {"ru": "Вы можете дождаться завершения одной или нескольких асинхронных функций, используя действие \"Ждать завершение асинхронной функции\"."},
		"This action behaves differently in record and run mode. In run mode it creates a new thread and parallelizes workflow. In record mode it works almost the same as regular function call, because record mode only works with single thread.": {"ru": "Это действие ведет себя по-разному в режиме записи и запуска. В режиме запуска оно создает новый поток и распараллеливает процесс выполнения приложения. В режиме записи оно работает так же, как обычный вызов функции, потому что режим записи всегда однопоточный."},
		"This action returns thread id inside THREAD_ID variable. This identifier allows communicating with function, with help of it you can: obtain function result, wait for function completion or stop function.": {"ru": "Это действие сохраняет ID потока в переменную THREAD_ID. Этот идентификатор позволяет взаимодействовать с функцией, с помощью него вы можете: получить результат функции, дождаться завершения ее выполнения или остановить функцию."},
		"Use 'Wait for async function completion' and then 'Get async function result' to get async function result": {"ru": "Используйте действие \"Ждать завершение асинхронной функции\", а затем \"Получить результат асинхронной функции\", чтобы получить результат выполнения"},
		"It also adds thread identifier to THREAD_LIST variable. This variable has a list type and can be processed with \"List\" module. It accumulates all started threads so, you can perform bulk actions on it, for example, stop them immediately all together.": {"ru": "Данное действие также добавляет ID потока в переменную THREAD_LIST. Эта переменная имеет тип список и может обрабатываться модулем \"Список\". Он накапливает все запущенные потоки, поэтому вы можете выполнять с помощью него действия сразу над несколькими потоками, например, немедленно останавливать их."},
		"Script execution won't finish until at least one asynchronous function is working. You can use that behavior to stop script automatically when all tasks are done. For example, if main thread starts two functions, one takes 1 minute and second takes 2 minutes. In that case, script will finish in 2 minutes even if main thread will finish immediately after start.": {"ru": "Выполнение скрипта не завершится, пока будет работать хотя бы одна асинхронная функция. Вы можете использовать это поведение для автоматической остановки скрипта, когда все задачи выполнены. Расмотрим пример, если основной поток запускает две функции, выполнение одной занимает 1 минуту, а второй - 2 минуты. В этом случае скрипт завершится через 2 минуты, даже если основной поток завершит работу сразу после запуска."},
		"You can limit maximum number of simultaneously running threads with async functions by setting \"Maximum async tasks executed simultaneously\" parameter. If function will be started beyond the limit, it will be postponed and will be started immediately after some other async function will finish and the limit will not be exceeded. This is very powerful setting, it allows you to start as many threads as you want and let BAS balance thread number.": {"ru": "Вы можете ограничить максимальное количество одновременно работающих потоков с асинхронными функциями, установив параметр \"Максимальное количество асинхронных функций, выполняемых одновременно\". Если функция будет запущена свыше этого предела, она будет отложена до того момента, когда завершится какая-то другая функция и число потоков упадет ниже предела. Это очень мощная настройка, она позволяет запускать неограниченное число потоков, при этом BAS будет балансировать нагрузку самостоятельно."},
		"By default, function will be started in a new thread, and after function will finish, thread will be deleted. However, you can keep thread running and even execute new function in it after old is finished. Next function will share same context - same browser and local variables. Consider following example, there are two functions: SetProxy and DoParsing, if you execute them in different threads, parsing will be performed with real ip, and if you execute them in same thread sequentially, parsing will be performed through proxy. In order to start function in old thread, set \"Desired thread id\" to old thread id, you need also to set \"Close thread after function finish\" parameter to false.": {"ru": "По умолчанию функция будет запущена в новом потоке, а после завершения функции поток будет удален. Тем не менее, вы можете поддерживать работу потока и даже запустить в нем новую функцию после завершения старой. Запущенная в старом потоке функция будет иметь тот же контекст - тот же браузер и те же локальные переменные. Рассмотрим следующий пример - есть две функции: SetProxy и DoParsing. Если вы выполняете их в разных потоках, парсинг будет выполняться с реальным ip, а если вы выполняете их в одном и том же потоке последовательно, парсинг будет выполняться через прокси. Чтобы запустить функцию в ранее использованном потоке, установите у параметра \"Желаемый ID потока\" значение ID этого потока, также необходимо установить у параметра \"Остановить поток после завершения функции\" значение false."},
		"If new function will be started in thread, that already has function started, new function will be postponed. This new function will be started immediately after old one gets finished.": {"ru": "Если в потоке будет запущена функция, в то время, пока идет выполнение какой-то другой функции, то новая будет отложена. Она будет запущена сразу после завершения старой."},
		"Thread id": {"ru": "ID потока"},
		"Thread identifier obtained from 'Call function asynchronously' action. In case if parameter is a list, this action will wait for all async functions in a list to finish.": {"ru": "ID потока, полученный из действия \"Вызов функции асинхронно\". Если параметр является списком, это действие будет ожидать завершения всех асинхронных функций в списке."},
		"Wait for single function.": {"ru": "Ждать завершения одной функции."},
		"Wait for all functions in the list.": {"ru": "Ждать завершения всех функций в списке."},
		"Wait for async function to finish.": {"ru": "Ждать завершения асинхронной функции."},
		"In order to use this action, function must be started asynchronously with 'Call function asynchronously' action.": {"ru": "Для работы этого действия необходимо, чтобы функция запускалась асинхронно с помощью действия \"Вызов функции асинхронно\"."},
		"It is important to understand that async function call returns immediately, and you can obtain its actual result by waiting for function completion with this action.": {"ru": "Важно понимать, что действие \"Вызов функции асинхронно\" немедленно завершает свою работу после запуска, и вы можете получить результат выполнения функции только дождавшись ее завершения с помощью этого действия."},
		"This action may wait for single function or for list of functions. In order to wait for list, place variable with list type into 'Thread id' parameter, usually its name is THREAD_LIST and it is obtained as a result of 'Call function asynchronously' action.": {"ru": "Это действие может ожидать как отдельную функцию, так и список функций. Чтобы дождаться окончания работы списка функций, установите переменную с типом список в параметр \"ID потока\", обычно ее имя - THREAD_LIST, в нем накапливаются ID потоков в результате работы действия \"Вызов функции асинхронно\"."},
		"By default this action will wait infinite amount of time, but you can specify maximum time to wait. If function will not complete by that time, it will be stopped and error will raise. You can process error with \"Ignore Errors\" action. Setting maximum time to wait is very convinient way to set timeout to any function.": {"ru": "По умолчанию это действие будет ожидать бесконечное количество времени, но вы можете указать максимальное время ожидания. Если функция не завершится к этому времени, она будет остановлена и возникнет ошибка. Вы можете обработать ошибку с помощью действия \"Игнорировать ошибки\". Установка максимального времени ожидания - очень удобный способ ограничить время выполнения для любой функции."},
		"Correct workflow to wait for several functions may look like": {"ru": "Пример ожидания нескольких функций может выглядеть вот"},
		"this": {"ru": "так"},
		"Thread identifier obtained from 'Call function asynchronously' action. In case if parameter is a list, this action will stop all async functions in a list.": {"ru": "ID потока, полученный из действия \"Вызов функции асинхронно\". Если параметр является списком, это действие остановит все асинхронные функций в этом списке."},
		"Stop single function.": {"ru": "Остановить одну функцию."},
		"Stop all functions in the list.": {"ru": "Остановить все функции из списка."},
		"Stop async function.": {"ru": "Прервать вызов асинхронной функции."},
		"This action will immediately stop asynchronous function execution.": {"ru": "Это действие немедленно остановит выполнение асинхронной функции."},
		"If \"Thread id\" parameter contains list, each thread from this list will be stopped.": {"ru": "Если параметр \"ID потока\" содержит список, то каждый поток из этого списка будет остановлен."},
		"This action only works with async functions created with \"Call function asynchronously\" action.": {"ru": "Это действие работает только с асинхронными функциями, созданными с помощью действия \"Вызов функции асинхронно\"."},
		"Thread identifier obtained from 'Call function asynchronously' action.": {"ru": "ID потока, полученный из действия \"Вызов функции асинхронно\"."},
		"Result of thread execution. In order to set this value from executed function, you need to use 'Result' action. If there was no call of 'Result' action inside function, null will be returned.": {"ru": "Результат работы асинхронной функции. Чтобы установить это значение из выполняемой функции, вам нужно использовать действие \"Return\". Если в функции не было вызова действия \"Return\", возвращается значение null."},
		"Boolean value(true/false) indicates if function is still running.": {"ru": "Логическое значение(true/false) указывает, работает ли функция в данный момент."},
		"Boolean value(true/false) indicates if last function execution was successful.": {"ru": "Логическое значение(true/false) указывает, был ли результат последнего выполнения успешным."},
		"Error string in case if last function call was not successful.": {"ru": "Строка с ошибкой в случае, если последний вызов функции не был успешным."},
		"Is running": {"ru": "Работает ли функция"},
		"Is success": {"ru": "Результат выполнения успешный"},
		"Error string": {"ru": "Строка с ошибкой"},
		"Obtain asynchronous function result.": {"ru": "Получить результат выполнения асинхронной функции."},
		"It is important to understand that async function call returns immediately without result, and you can obtain its actual result only by calling this action later, when function will finish.": {"ru": "Важно понимать, что действие \"Вызов функции асинхронно\" немедленно завершает свою работу после запуска, и чтобы получить результат выполнения функции нужно предварительно дождавшись ее завершения с помощью действия \"Ждать завершение асинхронной функции\"."},
		"This action obtains result of function execution, it also helps to obtain function state, if it is still running and if there was error during execution.": {"ru": "Это действие получает результат выполнения функции, оно также помогает узнать состояние функции, то есть выполняется ли она в данный момент и являлось ли последнее выполнение успешным."},
		"It makes no sense to check THREAD_RESULT until THREAD_IS_RUNNING is set to true, ie until function is still running.": {"ru": "Нет смысла проверять значение переменной THREAD_RESULT до тех пор, пока переменная THREAD_IS_RUNNING не будет равна false, то есть до тех пор, пока функция все еще работает."},
		"You can use THREAD_IS_RUNNING to wait for function result, but it is much easier to use 'Wait for async function completion' action.": {"ru": "Вы можете использовать переменную THREAD_IS_RUNNING для ожидания результата функции, но гораздо проще использовать действие \"Ждать завершение асинхронной функции\"."},
		"If there was error during function call, use THREAD_IS_SUCCESS and THREAD_ERROR to check it and obtain error message.": {"ru": "Если во время вызова функции произошла ошибка, используйте переменную THREAD_IS_SUCCESS и THREAD_ERROR, чтобы проверить было ли выполнение успешным и получить сообщение об ошибке."},
		"Correct workflow to get async function result may look like": {"ru": "Пример получения результата асинхронной функции может выглядеть вот"},

		"This setting defines behavior, which will be performed on idle, ie when function will finish but thread will remain active. By using 'start postponded function' option you can achieve such behavior, when all functions will be executed in same pool of threads. This will help to save resources needed to restrat threads and browsers. Don't forget to set 'Close thread after function finish' to false, otherwise threads will be closed automatically, idle state won't be achieved and effect will be neglected.": {"ru": "Этот параметр определяет поведение во время бездействия потока, т.е. когда функция завершится, но поток останется активным. Используя опцию 'start postponded function', вы можете добиться такого поведения, когда все функции будут выполняться в одном и том же пуле потоков. Это поможет сэкономить ресурсы, необходимые для перезапуска потоков и браузеров. Не забудьте установить для параметра 'Остановить поток после завершения функции' значение false, иначе потоки будут закрываться автоматически вместо перехода в состояние бездействия."},
		"Default. When thread has no work to do, it will wait to new function call.": {"ru": "Значение по умолчанию. Когда поток находится в состоянии бездействия, он будет ждать вызова новой функции."},
		"In idle state thread will look for postdonded functions, thoose, which was queued due to 'Maximum async tasks executed simultaneously' setting. If such function will be found, it will be executed in current thread.": {"ru": "В состоянии бездействия поток будет искать отложенные функции, то есть те, которые были поставлены в очередь из-за установки 'Максимальное количество асинхронных функций, выполняемых одновременно'. Если такая функция будет найдена, она будет выполнена в текущем потоке."},
		"On idle": {"ru": "Поведение во время бездействия потока"}
				
	},
	"engine": [],
	"browser": [],
	"depends": []	
}

